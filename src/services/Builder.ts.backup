/**
 * Build orchestration system for Java EE projects
 * Handles deployment strategies, project analysis, and smart auto-deployment
 */

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { exec } from 'child_process';
import { env } from 'vscode';
import { glob } from 'glob';
import { Tomcat } from './Tomcat';
import { Logger } from './Logger';
// import { promisify } from 'util';

// const execAsync = promisify(exec);

const tomcat = Tomcat.getInstance();
const logger = Logger.getInstance();

interface ProjectStructure {
    type: 'maven' | 'gradle' | 'eclipse' | 'plain';
    javaOutputDir: string;
    javaSourceRoots: string[];
    webResourceRoots: string[];
    webappName: string;
}

/** Smart deploy file mapping configuration */
interface SmartDeployMapping {
    source: string; // Source pattern (glob)
    destination: string; // Destination pattern (supports {relative} placeholder)
    needsReload: boolean; // Whether this mapping requires Tomcat reload
    description?: string; // Optional description
    extensions?: string[]; // File extensions to include
    excludeExtensions?: string[]; // File extensions to exclude
}

interface SmartDeployConfig {
    projectType: string; // Project type (maven, gradle, eclipse, plain)
    webappName: string; // Tomcat webapp name  
    mappings: SmartDeployMapping[]; // Array of file mappings
    settings: {
        debounceTime: number; // Debounce time in milliseconds
        enabled: boolean; // Enable/disable smart deploy
        logLevel: 'debug' | 'info' | 'warn' | 'error'; // Log level for smart deploy
    };
}

/** Default mapping templates for different project types */
const DEFAULT_MAPPINGS: Record<string, SmartDeployMapping[]> = {
    maven: [
        {
            source: 'target/classes/**/*.class',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Java compiled classes',
            extensions: ['.class']
        },
        {
            source: 'src/main/webapp/**/*',
            destination: '{relative}',
            needsReload: false,
            description: 'Static web resources',
            excludeExtensions: ['.class', '.java']
        },
        {
            source: 'src/main/resources/**/*',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Resource files',
            excludeExtensions: ['.class', '.java']
        }
    ],
    gradle: [
        {
            source: 'build/classes/java/main/**/*.class',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Java compiled classes',
            extensions: ['.class']
        },
        {
            source: 'src/main/webapp/**/*',
            destination: '{relative}',
            needsReload: false,
            description: 'Static web resources',
            excludeExtensions: ['.class', '.java']
        },
        {
            source: 'src/main/resources/**/*',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Resource files',
            excludeExtensions: ['.class', '.java']
        }
    ],
    eclipse: [
        {
            source: 'bin/**/*.class',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Java compiled classes',
            extensions: ['.class']
        },
        {
            source: 'WebContent/**/*',
            destination: '{relative}',
            needsReload: false,
            description: 'Static web resources',
            excludeExtensions: ['.class', '.java']
        }
    ],
    plain: [
        {
            source: 'bin/**/*.class',
            destination: 'WEB-INF/classes/{relative}',
            needsReload: true,
            description: 'Java compiled classes',
            extensions: ['.class']
        },
        {
            source: 'web/**/*',
            destination: '{relative}',
            needsReload: false,
            description: 'Static web resources',
            excludeExtensions: ['.class', '.java']
        }
    ]
};

/**
 * Compiled mapping for runtime efficiency
 */
interface CompiledMapping extends SmartDeployMapping {
    /** Absolute source pattern */
    absoluteSource: string;
    /** Absolute destination path template */
    absoluteDestination: string;
    /** Compiled regex for source matching */
    sourceRegex: RegExp;
}

export class Builder {
    private static instance: Builder;
    private autoDeployMode: 'Disable' | 'Smart';
    private isDeploying = false;
    private attempts = 0;
    
    // Enhanced Smart deploy properties (dual-watcher architecture with batch processing)
    private fileWatchers: vscode.FileSystemWatcher[] = []; // Contains both static and compiled file watchers
    private staticResourceDebouncer = new Map<string, NodeJS.Timeout>(); // For static resources (immediate)
    
    // Batch processing for compiled files
    private compiledFileDebouncer = new Map<string, NodeJS.Timeout>(); // Individual file debouncer (legacy)
    private batchDeploymentTimer?: NodeJS.Timeout; // Global batch timer
    private pendingCompiledFiles = new Set<string>(); // Files waiting for batch deployment
    
    private projectStructure?: ProjectStructure;
    private smartDeployConfig?: SmartDeployConfig;
    private compiledMappings?: CompiledMapping[];

    // Legacy code (commented out for new implementation)
    // private deployDebouncer = new Map<string, NodeJS.Timeout>();

    // Configuration file name (legacy, kept for reference)
    private static readonly CONFIG_FILE = '.vscode/tomcat-smart-deploy.json';

    /**
     * Private constructor - initialize configuration and state
     */
    private constructor() {
        // Use smartDeploy setting
        this.autoDeployMode = vscode.workspace.getConfiguration().get('turbocat.smartDeploy', 'Disable') as 'Disable' | 'Smart';
    }

    /**
     * Get singleton Builder instance
     */
    public static getInstance(): Builder {
        if (!Builder.instance) {
            Builder.instance = new Builder();
        }
        return Builder.instance;
    }

    /**
     * Update configuration from workspace settings
     */
    public updateConfig(): void {
        // Use smartDeploy setting
        this.autoDeployMode = vscode.workspace.getConfiguration().get('turbocat.smartDeploy', 'Disable') as 'Disable' | 'Smart';
    }

    /**
     * Java EE Project Detection
     * 
     * Comprehensive project structure analysis implementing:
     * 1. Standard directory layout verification
     * 2. Web application descriptor detection
     * 3. Build system configuration analysis
     * 4. Existing artifact inspection
     * 5. Framework signature detection
     * 
     * @returns Boolean indicating Java EE project validity
     */
    public static isJavaEEProject(): boolean {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) { return false; }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const webInfPath = path.join(rootPath, 'src', 'main', 'webapp', 'WEB-INF');
        
        if (fs.existsSync(webInfPath)) { return true; }
        if (fs.existsSync(path.join(webInfPath, 'web.xml'))) { return true; }

        const pomPath = path.join(rootPath, 'pom.xml');
        if (fs.existsSync(pomPath) && fs.readFileSync(pomPath, 'utf-8').includes('<packaging>war</packaging>')) {
            return true;
        }

        const gradlePath = path.join(rootPath, 'build.gradle');
        if (fs.existsSync(gradlePath) && fs.readFileSync(gradlePath, 'utf-8').match(/(tomcat|jakarta|javax\.ee)/i)) {
            return true;
        }

        const targetPath = path.join(rootPath, 'target');
        if (fs.existsSync(targetPath) && fs.readdirSync(targetPath).some(file => file.endsWith('.war') || file.endsWith('.ear'))) {
            return true;
        }

        return false;
    }

    /**
     * Project Structure Detection
     * 
     * Auto-detects project structure and configuration for smart deployment:
     * 1. Maven project detection and configuration
     * 2. Gradle project detection and configuration  
     * 3. Eclipse project detection and configuration
     * 4. Plain Java project fallback
     * 
     * @returns ProjectStructure with detected configuration
     */
    public detectProjectStructure(): ProjectStructure {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error('No workspace folder found');
        }

        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        
        // Maven detection
        if (fs.existsSync(path.join(workspaceRoot, 'pom.xml'))) {
            return {
                type: 'maven',
                javaOutputDir: 'target/classes',
                javaSourceRoots: ['src/main/java'],
                webResourceRoots: ['src/main/webapp'],
                webappName: this.getMavenArtifactId(workspaceRoot) || path.basename(workspaceRoot)
            };
        }
        
        // Gradle detection
        if (fs.existsSync(path.join(workspaceRoot, 'build.gradle')) || 
            fs.existsSync(path.join(workspaceRoot, 'build.gradle.kts'))) {
            return {
                type: 'gradle',
                javaOutputDir: 'build/classes/java/main',
                javaSourceRoots: ['src/main/java'],
                webResourceRoots: ['src/main/webapp'],
                webappName: this.getGradleProjectName(workspaceRoot) || path.basename(workspaceRoot)
            };
        }
        
        // Eclipse/Plain Java detection
        if (fs.existsSync(path.join(workspaceRoot, '.classpath'))) {
            return {
                type: 'eclipse',
                javaOutputDir: 'bin',
                javaSourceRoots: ['src'],
                webResourceRoots: ['WebContent', 'web'],
                webappName: path.basename(workspaceRoot)
            };
        }
        
        // Default fallback
        return {
            type: 'plain',
            javaOutputDir: 'bin',
            javaSourceRoots: ['src'],
            webResourceRoots: ['web', 'webapp'],
            webappName: path.basename(workspaceRoot)
        };
    }

    /**
     * Extract Maven artifact ID from pom.xml
     */
    private getMavenArtifactId(workspaceRoot: string): string | null {
        try {
            const pomPath = path.join(workspaceRoot, 'pom.xml');
            const pomContent = fs.readFileSync(pomPath, 'utf-8');
            const artifactIdMatch = pomContent.match(/<artifactId>(.*?)<\/artifactId>/);
            return artifactIdMatch ? artifactIdMatch[1] : null;
        } catch {
            return null;
        }
    }

    /**
     * Extract Gradle project name from settings.gradle
     */
    private getGradleProjectName(workspaceRoot: string): string | null {
        try {
            const settingsPath = path.join(workspaceRoot, 'settings.gradle');
            if (fs.existsSync(settingsPath)) {
                const settingsContent = fs.readFileSync(settingsPath, 'utf-8');
                const nameMatch = settingsContent.match(/rootProject\.name\s*=\s*['"]([^'"]+)['"]/);
                return nameMatch ? nameMatch[1] : null;
            }
            return null;
        } catch {
            return null;
        }
    }

    /**
     * Build and Deployment Orchestrator
     * 
     * Centralized deployment control implementing:
     * 1. Project validation
     * 2. Build strategy selection
     * 3. Target environment preparation
     * 4. Build execution
     * 5. Post-deployment actions
     * 
     * @param type Build strategy ('Local' | 'Maven' | 'Gradle' | 'Choice')
     * @log Deployment progress and errors
     */
    public async deploy(type: 'Local' | 'Maven' | 'Gradle' | 'Choice'): Promise<void> {
        const projectDir = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!projectDir || !Builder.isJavaEEProject()) {
            await this.createNewProject();
            return;
        }
        let isChoice;

        if (type === 'Choice') {
            isChoice = true;
            const subAction = vscode.window.showQuickPick(['Local', 'Maven', 'Gradle'], {
                placeHolder: 'Select build type'
            });
            await subAction.then((choice) => {
                type = (choice as 'Local' | 'Maven' | 'Gradle');
            });
            if (!type || type === 'Choice') { return; }
        }

        const appName = path.basename(projectDir);
        const tomcatHome = await tomcat.findTomcatHome();
        
        tomcat.setAppName(appName);

        if (!tomcatHome || !appName || !fs.existsSync(path.join(tomcatHome, 'webapps'))) { return; }

        const targetDir = path.join(tomcatHome, 'webapps', appName);
        await vscode.workspace.saveAll();

        try {            
            const action = {
                'Local': () => this.localDeploy(projectDir, targetDir, tomcatHome),
                'Maven': () => this.mavenDeploy(projectDir, targetDir),
                'Gradle': () => this.gradleDeploy(projectDir, targetDir, appName),
            }[type];

            if (!action) {
                throw(`Invalid deployment type: ${type}`);
            }

            const startTime = performance.now();

            if (isChoice) {
                await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: `${type} Build`,
                    cancellable: false
                }, action);
            } else {
                await action();
            }

            //logger.defaultStatusBar();

            const endTime = performance.now();
            const duration = Math.round(endTime - startTime);

            if (fs.existsSync(targetDir)) {
                logger.success(`${type} Build completed in ${duration}ms`, isChoice);
                await new Promise(resolve => setTimeout(resolve, 100));
                await tomcat.reload();
            }

            this.attempts = 0;
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            const isBusyError = errorMessage.includes('EBUSY') || errorMessage.includes('resource busy or locked');
            if (isBusyError && this.attempts < 3) {
                this.attempts++;
                await tomcat.kill();
                this.deploy(type);
            } else {
                logger.error(`${type} Build failed:`, isChoice, err as string);
            }
            //logger.defaultStatusBar();
        } finally {
            //logger.defaultStatusBar();
        }
    }

    /**
     * Automated Deployment Trigger
     * 
     * Implements intelligent deployment automation with:
     * 1. Save event analysis
     * 2. Build type resolution
     * 3. Smart deploy initialization
     * 4. Concurrency control
     * 5. Error handling
     * 
     * @deprecated Parameter reason is unused but kept for backward compatibility
     */
    public async autoDeploy(_reason: vscode.TextDocumentSaveReason): Promise<void> {
        if (this.isDeploying || !Builder.isJavaEEProject()) { return; }
    
        try {
            this.isDeploying = true;
            
            if (this.autoDeployMode === 'Smart') {
                // Smart deploy is handled by file system watchers
                // This ensures smart deploy is initialized if not already
                if (!this.projectStructure) {
                    this.initializeSmartDeploy().catch(error => 
                        logger.error('Failed to initialize smart deploy', false, error as string)
                    );
                }
            }
            // No other deployment modes are supported anymore
        } finally {
            this.isDeploying = false;
        }
    }

    /**
     * Initialize Dual-Watcher Smart Deploy System
     * 
     * Implements dual-watcher architecture for optimal deployment performance:
     * 1. Static Resource Watcher: monitors src folder for immediate deployment
     * 2. Compiled File Watcher: monitors target/build folders for delayed batch deployment
     */
    public async initializeSmartDeploy(): Promise<void> {
        // Update autoDeployMode from config to ensure it's current
        this.autoDeployMode = vscode.workspace.getConfiguration().get('turbocat.smartDeploy', 'Disable') as 'Disable' | 'Smart';
        
        if (this.autoDeployMode !== 'Smart') {
            logger.debug('Smart deploy not initialized - mode is not Smart');
            return;
        }

        try {
            logger.debug('Initializing hybrid smart deploy system...');
            
            // Check current workspace
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                logger.error('No workspace folders found', false, 'Smart deploy requires an open workspace');
                return;
            }
            
            // Detect project structure
            this.projectStructure = this.detectProjectStructure();
            logger.debug(`Detected project structure: ${JSON.stringify(this.projectStructure)}`);
            
            // Load or create smart deploy configuration
            this.smartDeployConfig = await this.loadSmartDeployConfig();
            
            // Compile mappings for runtime efficiency
            this.compiledMappings = this.compileMappings(this.smartDeployConfig);
            
            // Setup dual-watcher architecture
            this.setupDualFileWatchers();
            
            logger.info('✓ Dual-watcher smart deploy initialized successfully');
            logger.info(`  - Project type: ${this.projectStructure.type}`);
            logger.info(`  - Java output: ${this.projectStructure.javaOutputDir}`);
            logger.info(`  - Webapp name: ${this.projectStructure.webappName}`);
            logger.info(`  - Mappings: ${this.compiledMappings.length} configured`);
            logger.info(`  - Architecture: Dual-watcher (static + compiled)`);
            logger.info(`  - Config file: ${Builder.CONFIG_FILE}`);
        } catch (error) {
            logger.error('Failed to initialize smart deploy', false, error as string);
        }
    }

    /**
     * Setup dual-watcher architecture for optimized smart deployment
     * 
     * Architecture:
     * 1. Static Resource Watcher: monitors src folder (excluding java files)
     *    - Immediate deployment (0ms delay)
     *    - Handles HTML, CSS, JS, JSP, config files, etc.
     * 
     * 2. Compiled File Watcher: monitors target/classes and build/classes
     *    - Delayed deployment (configurable, default 300ms)
     *    - Handles compiled Java classes
     */
    private setupDualFileWatchers(): void {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) {
            logger.debug('Dual watcher setup failed: No workspace root');
            return;
        }

        // Dispose existing watchers
        this.disposeFileWatchers();

        logger.info(`🎯 Setting up dual-watcher smart deployment architecture`);
        logger.info(`📋 Features: Static resources (immediate) + Compiled classes (delayed)`);
        
        // 1. Static Resource Watcher - src/**/* excluding .java files
        this.setupStaticResourceWatcher(workspaceRoot);
        
        // 2. Compiled File Watcher - target/classes/**/*.class or build/classes/**/*.class
        this.setupCompiledFileWatcher(workspaceRoot);
        
        logger.info(`✅ Dual-watcher setup complete`);
    }

    /**
     * Setup static resource file watcher for immediate deployment
     */
    private setupStaticResourceWatcher(workspaceRoot: string): void {
        // Monitor src directory but exclude Java files
        const srcPattern = new vscode.RelativePattern(workspaceRoot, 'src/**/*');
        const staticWatcher = vscode.workspace.createFileSystemWatcher(srcPattern);
        
        logger.info(`📁 Static Resource Watcher: ${workspaceRoot}/src (excluding .java files)`);
        logger.info(`⚡ Strategy: Immediate deployment for web resources`);
        
        // Set up event handlers for static resources
        staticWatcher.onDidChange((uri: vscode.Uri) => this.handleStaticResourceChange(uri, 'change'));
        staticWatcher.onDidCreate((uri: vscode.Uri) => this.handleStaticResourceChange(uri, 'create'));
        staticWatcher.onDidDelete?.((uri: vscode.Uri) => this.handleStaticResourceChange(uri, 'delete'));
        
        this.fileWatchers.push(staticWatcher);
        logger.info(`✓ Static resource watcher active`);
    }

    /**
     * Setup compiled file watcher for delayed deployment
     */
    private setupCompiledFileWatcher(workspaceRoot: string): void {
        if (!this.projectStructure) return;

        // Determine output directory pattern based on project type
        let outputPattern: string;
        switch (this.projectStructure.type) {
            case 'maven':
                outputPattern = 'target/classes/**/*.class';
                break;
            case 'gradle':
                outputPattern = 'build/classes/java/main/**/*.class';
                break;
            case 'eclipse':
            case 'plain':
            default:
                outputPattern = 'bin/**/*.class';
                break;
        }

        const compiledPattern = new vscode.RelativePattern(workspaceRoot, outputPattern);
        const compiledWatcher = vscode.workspace.createFileSystemWatcher(compiledPattern);
        
        logger.info(`� Compiled File Watcher: ${workspaceRoot}/${outputPattern}`);
        logger.info(`⏱️ Strategy: Delayed deployment for compiled classes`);
        
        // Set up event handlers for compiled files
        compiledWatcher.onDidChange((uri: vscode.Uri) => this.handleCompiledFileChange(uri, 'change'));
        compiledWatcher.onDidCreate((uri: vscode.Uri) => this.handleCompiledFileChange(uri, 'create'));
        compiledWatcher.onDidDelete?.((uri: vscode.Uri) => this.handleCompiledFileChange(uri, 'delete'));
        
        this.fileWatchers.push(compiledWatcher);
        logger.info(`✓ Compiled file watcher active`);
    }

    /**
     * Dispose the unified file watcher
     */
    private disposeFileWatchers(): void {
        this.fileWatchers.forEach(watcher => watcher.dispose());
        this.fileWatchers = [];
    }

    // LEGACY: Old unified file change handler (commented out)
    // private handleSourceFileChange(uri: vscode.Uri, eventType: 'change' | 'create' | 'delete'): void {
    //     ... (old implementation commented out)
    // }

    /**
     * NEW: Handle static resource file changes (immediate deployment)
     * Processes non-Java files from src directory with zero delay
     */
    private handleStaticResourceChange(uri: vscode.Uri, eventType: 'change' | 'create' | 'delete'): void {
        const fileName = path.basename(uri.fsPath);
        const fileExt = path.extname(uri.fsPath).toLowerCase();
        
        // Skip hidden files, temp files, and Java files
        if (fileName.startsWith('.') || fileName.endsWith('.tmp') || fileName.endsWith('.temp') || fileExt === '.java' || fileExt === '.svn') {
            logger.debug(`Skipping file: ${fileName} (${fileExt === '.java' ? 'Java file handled by compiled watcher' : 'temp/hidden file'})`);
            return;
        }
        
        // Get relative path from workspace root
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return;
        
        const relativePath = path.relative(workspaceRoot, uri.fsPath);
        logger.info(`🔥 Static resource ${eventType}: ${fileName} (${relativePath})`);
        
        // Immediate deployment for static resources (no debouncing)
        this.deployStaticResourceImmediately(uri.fsPath, eventType);
    }

    /**
     * NEW: Handle compiled file changes with intelligent batch processing
     * Processes .class files from target/build directories with batch optimization
     */
    private handleCompiledFileChange(uri: vscode.Uri, eventType: 'change' | 'create' | 'delete'): void {
        const fileName = path.basename(uri.fsPath);
        const fileExt = path.extname(uri.fsPath).toLowerCase();
        
        // Only process .class files
        if (fileExt !== '.class') {
            logger.debug(`Skipping non-class file: ${fileName}`);
            return;
        }
        
        // Get relative path from workspace root
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return;
        
        const relativePath = path.relative(workspaceRoot, uri.fsPath);
        logger.info(`🔧 Compiled file ${eventType}: ${fileName} (${relativePath})`);
        
        // Use batch deployment for compiled files
        this.addToBatchDeployment(uri.fsPath, eventType);
    }

    // LEGACY: Old deployment methods (commented out for new dual-watcher architecture)
    // These methods were used in the previous hybrid approach
    
    /*
    private async deployCompiledClassWithMapping(sourceJavaPath: string, relativePath: string): Promise<void> {
        // ... (implementation commented out)
    }

    private async deploySourceFileWithMapping(sourceFilePath: string): Promise<void> {
        // ... (implementation commented out)  
    }
    */

    /**
     * NEW: Immediate deployment for static resources (no debouncing)
     */
    private async deployStaticResourceImmediately(filePath: string, eventType: 'change' | 'create' | 'delete'): Promise<void> {
        try {
            if (eventType === 'delete') {
                logger.debug(`Static resource deleted: ${path.basename(filePath)}`);
                // TODO: Handle deletion - remove corresponding deployed files
                return;
            }

            // Find matching mapping for the source file
            const mapping = this.findMatchingMapping(filePath);
            if (!mapping) {
                const fileName = path.basename(filePath);
                logger.debug(`❌ No mapping found for static resource: ${fileName}`);
                return;
            }
            
            // Generate destination path using mapping configuration
            const targetPath = await this.generateDestinationPath(mapping, filePath);
            if (!targetPath) {
                const fileName = path.basename(filePath);
                logger.warn(`Failed to generate target path for: ${fileName}`);
                return;
            }
            
            await this.copyFileWithLogging(filePath, targetPath, 'static');
            
            const fileName = path.basename(filePath);
            const tomcatHome = await tomcat.findTomcatHome();
            const relativePath = tomcatHome ? path.relative(path.join(tomcatHome, 'webapps'), targetPath) : path.basename(targetPath);
            logger.info(`✓ Immediate deployed static: ${fileName} → ${relativePath}`);
            
        } catch (error) {
            logger.error(`Static resource deployment failed for ${path.basename(filePath)}`, false, error as string);
        }
    }

    /**
     * NEW: Add file to batch deployment queue with intelligent batching
     * Collects multiple class file changes and deploys them together
     */
    private addToBatchDeployment(filePath: string, eventType: 'change' | 'create' | 'delete'): void {
        const debounceTime = vscode.workspace.getConfiguration('turbocat').get<number>('smartDeployDebounce', 300);
        
        // Add file to pending batch (using Map to store both path and event type)
        this.pendingCompiledFiles.add(JSON.stringify({ filePath, eventType }));
        
        logger.debug(`📦 Added to batch: ${path.basename(filePath)} (${eventType}) - ${this.pendingCompiledFiles.size} files queued`);
        
        // Clear existing batch timer and start new one
        if (this.batchDeploymentTimer) {
            clearTimeout(this.batchDeploymentTimer);
        }
        
        this.batchDeploymentTimer = setTimeout(async () => {
            await this.executeBatchDeployment();
        }, debounceTime);
    }

    /**
     * Execute batch deployment of all pending compiled files
     */
    private async executeBatchDeployment(): Promise<void> {
        if (this.pendingCompiledFiles.size === 0) {
            return;
        }

        const batchSize = this.pendingCompiledFiles.size;
        logger.info(`🚀 Executing batch deployment for ${batchSize} compiled files...`);
        
        // Convert Set to array and parse file information
        const filesToDeploy = Array.from(this.pendingCompiledFiles).map(item => JSON.parse(item));
        
        // Clear pending files
        this.pendingCompiledFiles.clear();
        this.batchDeploymentTimer = undefined;
        
        let successCount = 0;
        let errorCount = 0;
        
        // Deploy all files in batch
        for (const { filePath, eventType } of filesToDeploy) {
            try {
                await this.executeCompiledFileDeployment(filePath, eventType);
                successCount++;
            } catch (error) {
                logger.error(`Batch deploy failed for ${path.basename(filePath)}`, false, error as string);
                errorCount++;
            }
        }
        
        // Log batch results
        if (successCount > 0) {
            logger.info(`✅ Batch deployment completed: ${successCount} files deployed successfully`);
        }
        if (errorCount > 0) {
            logger.warn(`⚠️ Batch deployment had ${errorCount} errors`);
        }
        
        // Optional: Trigger single reload after batch deployment instead of per-file
        // This is more efficient for multiple class changes
        // TODO: Implement conditional reload based on mapping configuration
    }

    // LEGACY: Individual file deployment method (commented out in favor of batch processing)
    // private deployCompiledFileWithDelay(filePath: string, eventType: 'change' | 'create' | 'delete'): void {
    //     const debounceTime = vscode.workspace.getConfiguration('turbocat').get<number>('smartDeployDebounce', 300);
    //     
    //     logger.debug(`Compiled file debounce time: ${debounceTime}ms for file: ${path.basename(filePath)}`);
    //     
    //     if (this.compiledFileDebouncer.has(filePath)) {
    //         clearTimeout(this.compiledFileDebouncer.get(filePath)!);
    //     }
    //     
    //     this.compiledFileDebouncer.set(filePath, setTimeout(async () => {
    //         try {
    //             await this.executeCompiledFileDeployment(filePath, eventType);
    //         } catch (error) {
    //             logger.error(`Compiled deploy failed for ${path.basename(filePath)}`, false, error as string);
    //         } finally {
    //             this.compiledFileDebouncer.delete(filePath);
    //         }
    //     }, debounceTime));
    // }

    /**
     * Execute compiled file deployment logic
     */
    private async executeCompiledFileDeployment(filePath: string, eventType: 'change' | 'create' | 'delete'): Promise<void> {
        if (eventType === 'delete') {
            logger.debug(`Compiled file deleted: ${path.basename(filePath)}`);
            // TODO: Handle deletion - remove corresponding deployed files
            return;
        }

        // Find matching mapping for the compiled .class file
        const mapping = this.findMatchingMapping(filePath);
        if (!mapping) {
            logger.info(`❌ No mapping found for compiled class: ${path.relative(vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '', filePath)}`);
            return;
        }
        
        // Generate destination path using mapping configuration
        const targetPath = await this.generateDestinationPath(mapping, filePath);
        if (!targetPath) {
            logger.warn(`Failed to generate target path for: ${path.basename(filePath)}`);
            return;
        }
        
        await this.copyFileWithLogging(filePath, targetPath, 'class');
        
        const fileName = path.basename(filePath);
        const tomcatHome = await tomcat.findTomcatHome();
        const relativePath = tomcatHome ? path.relative(path.join(tomcatHome, 'webapps'), targetPath) : path.basename(targetPath);
        logger.info(`✓ Delayed deployed class: ${fileName} → ${relativePath}`);
    }

    // LEGACY: Old debounced deploy method (commented out)
    // private debouncedDeploy(filePath: string, deployFn: () => Promise<void>): void {
    //     const debounceTime = vscode.workspace.getConfiguration('turbocat').get<number>('smartDeployDebounce', 300);
    //     
    //     // Debug log to verify configuration is being read correctly
    //     logger.debug(`Smart Deploy debounce time: ${debounceTime}ms for file: ${path.basename(filePath)}`);
    //     
    //     if (this.deployDebouncer.has(filePath)) {
    //         clearTimeout(this.deployDebouncer.get(filePath)!);
    //     }
    //     
    //     this.deployDebouncer.set(filePath, setTimeout(async () => {
    //         try {
    //             await deployFn();
    //         } catch (error) {
    //             logger.error(`Smart deploy failed for ${path.basename(filePath)}`, false, error as string);
    //         } finally {
    //             this.deployDebouncer.delete(filePath);
    //         }
    //     }, debounceTime));
    // }

    /**
     * Copy file with progress indication and logging
     */
    private async copyFileWithLogging(source: string, target: string, type: 'class' | 'static'): Promise<void> {
        try {
            // Check if source file exists
            if (!fs.existsSync(source)) {
                logger.warn(`Smart deploy: Source file not found: ${path.basename(source)}`);
                return;
            }

            // Ensure target directory exists
            const targetDir = path.dirname(target);
            if (!fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }

            // Copy the file
            fs.copyFileSync(source, target);
            
            const fileName = path.basename(source);
            logger.info(`✓ Smart deployed ${type}: ${fileName}`);
        } catch (error) {
            throw error;
        }
    }

    /**
     * Check if file is a static web resource
     */
    // private isStaticWebResource(filePath: string): boolean {
    //     const webExtensions = [
    //         '.html', '.htm', '.css', '.js', '.json', '.xml', '.jsp', '.jspf', 
    //         '.tag', '.tld', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', 
    //         '.txt', '.properties', '.woff', '.woff2', '.ttf', '.eot', '.md'
    //     ];
        
    //     const ext = path.extname(filePath).toLowerCase();
        
    //     // Exclude files in typical output directories
    //     if (this.projectStructure) {
    //         const outputDir = this.projectStructure.javaOutputDir;
    //         if (filePath.includes(outputDir)) {
    //             return false;
    //         }
    //     }
        
    //     return webExtensions.includes(ext);
    // }

    /**
     * Dispose smart deploy watchers (dual-watcher approach with batch cleanup)
     */
    public disposeSmartDeploy(): void {
        this.disposeFileWatchers();
        
        // Clear any pending debounced operations for static resources
        this.staticResourceDebouncer.forEach(timeout => clearTimeout(timeout));
        this.staticResourceDebouncer.clear();
        
        // Clear individual compiled file debouncers (legacy)
        this.compiledFileDebouncer.forEach(timeout => clearTimeout(timeout));
        this.compiledFileDebouncer.clear();
        
        // Clear batch deployment timer and pending files
        if (this.batchDeploymentTimer) {
            clearTimeout(this.batchDeploymentTimer);
            this.batchDeploymentTimer = undefined;
        }
        this.pendingCompiledFiles.clear();
        
        logger.debug('🧹 Smart deploy cleanup: All watchers and timers disposed');
    }

    /**
     * Test method to manually test dual-watcher deployment
     */
    public async testDualWatcherDeploy(): Promise<void> {
        if (!this.projectStructure) {
            logger.debug('Test deploy: No project structure found');
            return;
        }

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) {
            logger.debug('Test deploy: No workspace root found');
            return;
        }

        logger.info('🧪 Testing dual-watcher deployment system...');

        try {
            // Test static resource deployment
            const srcPath = path.join(workspaceRoot, 'src');
            if (fs.existsSync(srcPath)) {
                const staticFiles = await this.findFiles(path.join(srcPath, '**', '*.{html,css,js,jsp}'));
                logger.debug(`Test deploy: Found ${staticFiles.length} static files`);
                
                for (const file of staticFiles.slice(0, 1)) { // Test with first file
                    logger.debug(`Test static deploy: Processing ${file}`);
                    const uri = vscode.Uri.file(file);
                    this.handleStaticResourceChange(uri, 'create');
                }
            }

            // Test compiled file deployment if target directory exists (simulate batch changes)
            const targetPath = path.join(workspaceRoot, this.projectStructure.javaOutputDir);
            if (fs.existsSync(targetPath)) {
                const classFiles = await this.findFiles(path.join(targetPath, '**', '*.class'));
                logger.debug(`Test deploy: Found ${classFiles.length} class files`);
                
                // Simulate multiple class files changing at once (batch scenario)
                const testFiles = classFiles.slice(0, Math.min(3, classFiles.length));
                logger.info(`🧪 Simulating batch change: ${testFiles.length} class files`);
                
                testFiles.forEach((file, index) => {
                    logger.debug(`Test batch compile deploy ${index + 1}: Processing ${file}`);
                    const uri = vscode.Uri.file(file);
                    // All files will be batched together automatically
                    this.handleCompiledFileChange(uri, 'create');
                });
                
                if (testFiles.length > 1) {
                    logger.info(`⏱️ Batch processing will execute in ${vscode.workspace.getConfiguration('turbocat').get<number>('smartDeployDebounce', 300)}ms...`);
                }
            }

            logger.info('✅ Dual-watcher deployment test completed');
        } catch (error) {
            logger.error('Dual-watcher test failed', false, error as string);
        }
    }
    
    /**
     * Project Scaffolding System
     * 
     * Implements new project initialization with:
     * 1. User confirmation flow
     * 2. Extension dependency verification
     * 3. Maven archetype selection
     * 4. Workspace configuration
     * 5. Error recovery
     * 
     */
    private async createNewProject(): Promise<void> {
        const answer = await vscode.window.showInformationMessage(
            'No Java EE project found. Do you want to create a new one?',
            'Yes', 'No'
        );

        if (answer === 'Yes') {
            try {
                const commands = await vscode.commands.getCommands();
                if (!commands.includes('java.project.create')) {
                    const installMessage = 'Java Extension Pack required for project creation';
                    vscode.window.showErrorMessage(installMessage, 'Install Extension').then(async choice => {
                        if (choice === 'Install Extension') {
                            await env.openExternal(vscode.Uri.parse(
                                'vscode:extension/vscjava.vscode-java-pack'
                            ));
                        }
                    });
                    return;
                }

                await vscode.commands.executeCommand('java.project.create', {
                    type: 'maven',
                    archetype: 'maven-archetype-webapp'
                });
                logger.info('New Maven web app project created');
            } catch (err) {
                vscode.window.showErrorMessage(
                    'Project creation failed. Ensure Java Extension Pack is installed and configured.',
                    'Open Extensions'
                ).then(choice => {
                    if (choice === 'Open Extensions') {
                        vscode.commands.executeCommand('workbench.extensions.action.showExtensions');
                    }
                });
            }
        } else {
            logger.success('Tomcat deploy canceled', true);
        }
    }

    /**
     * Local Deployment Strategy
     * 
     * Implements direct file synchronization with:
     * 1. Web application directory validation
     * 2. Java source compilation
     * 3. Resource copying
     * 4. Dependency management
     * 5. Atomic deployment
     * 
     * @param projectDir Source project directory
     * @param targetDir Target deployment directory
     * @param tomcatHome Tomcat installation directory
     * @throws Error if build fails or java source compilation fails or if webapp directory not found
     */
    private async localDeploy(projectDir: string, targetDir: string, tomcatHome: string) {
        const webAppPath = path.join(projectDir, 'src', 'main', 'webapp');
        if (!fs.existsSync(webAppPath)) {
            throw new Error(`WebApp directory not found: ${webAppPath}`);
        }
        const javaHome = await tomcat.findJavaHome();
        if (!javaHome) return;

        const javacPath = path.join(javaHome, 'bin', 'javac');
        const javaSourcePath = path.join(projectDir, 'src', 'main', 'java');
        const classesDir = path.join(targetDir, 'WEB-INF', 'classes');
    
        this.brutalSync(webAppPath, targetDir, true);
    
        fs.rmSync(classesDir, { force: true, recursive: true });
        fs.mkdirSync(classesDir, { recursive: true });
    
        if (fs.existsSync(javaSourcePath)) {
            const javaFiles = await this.findFiles(path.join(javaSourcePath, '**', '*.java'));
            if (javaFiles.length > 0) {
                const tomcatLibs = path.join(tomcatHome, 'lib', '*');
                const cmd = `"${javacPath}" -d "${classesDir}" -cp "${tomcatLibs}" ${javaFiles.map(f => `"${f}"`).join(' ')}`;
                await this.executeCommand(cmd, projectDir);
            }
        }
    
        const libDir = path.join(projectDir, 'lib');
        const targetLib = path.join(targetDir, 'WEB-INF', 'lib');
        this.brutalSync(libDir, targetLib);
    }

    /**
     * Maven Build Strategy
     * 
     * Implements full Maven lifecycle integration with:
     * 1. POM validation
     * 2. Clean package execution
     * 3. Error analysis
     * 4. Artifact handling
     * 5. Deployment synchronization
     * 
     * @param projectDir Source project directory
     * @param targetDir Target deployment directory
     * @throws Error if Maven build fails or artifact not found
     */
    private async mavenDeploy(projectDir: string, targetDir: string) {
        if (!fs.existsSync(path.join(projectDir, 'pom.xml'))) {
            throw('pom.xml not found.');
        }

        try {
            await this.executeCommand(`mvn clean package`, projectDir);
        } catch (err) {
            const errorOutput = err?.toString() || '';
        
            const lines = errorOutput
                .split('\n')
                .filter(line =>
                    line.includes('[ERROR]') &&
                    !line.includes('re-run Maven') &&
                    !line.includes('[Help') &&
                    !line.includes('Re-run Maven') &&
                    !line.includes('For more information') &&
                    !line.includes('http')
                )
                .map(line => line.replace('[ERROR]', '\t\t'));
        
            const uniqueLines = [...new Set(lines)];
                
            throw(uniqueLines.join('\n'));
        }

        const targetPath = path.join(projectDir, 'target');
        const warFiles = fs.readdirSync(targetPath).filter((file: string) => file.toLowerCase().endsWith('.war'));
        if (warFiles.length === 0) {
            throw('No WAR file found after Maven build.');
        }

        const warFileName = warFiles[0];
        const warFilePath = path.join(targetPath, warFileName);

        const warBaseName = path.basename(warFileName, '.war');
        const warFolderPath = path.join(targetPath, warBaseName);

        if (fs.existsSync(targetDir)) {
            fs.rmSync(targetDir, { recursive: true, force: true });
        }
        if (fs.existsSync(`${targetDir}.war`)) {
            fs.rmSync(`${targetDir}.war`, { force: true });
        }

        fs.copyFileSync(warFilePath, `${targetDir}.war`);

        if (fs.existsSync(warFolderPath)) {
            fs.mkdirSync(targetDir, { recursive: true });
            this.copyDirectorySync(warFolderPath, targetDir);
        }
    }

    /**
     * Gradle Build Strategy
     * 
     * Implements Gradle integration with:
     * 1. Build script validation
     * 2. War task execution
     * 3. Artifact naming control
     * 4. Deployment synchronization
     * 5. Cleanup procedures
     * 
     * @param projectDir Source project directory
     * @param targetDir Target deployment directory
     * @param appName Application name for artifact naming
     * @throws Error if Gradle build fails or artifact not found
     */
    private async gradleDeploy(projectDir: string, targetDir: string, appName: string) {
        if (!fs.existsSync(path.join(projectDir, 'build.gradle'))) {
            throw('build.gradle not found.');
        }

        const gradleCmd = process.platform === 'win32' ? 'gradlew.bat' : './gradlew';
        await this.executeCommand(`${gradleCmd} war -PfinalName=${appName}`, projectDir);

        const warFile = path.join(projectDir, 'build', 'libs', `${appName}.war`);
        if (!warFile) {
            throw('No WAR file found after Gradle build.');
        }

        fs.rmSync(targetDir, { recursive: true, force: true });
        fs.rmSync(`${targetDir}.war`, { recursive: true, force: true });
        fs.copyFileSync(warFile, `${targetDir}.war`);
    }

    /**
     * File System Utility - Pattern Matching
     * 
     * Implements robust file discovery with:
     * - Cross-platform path handling
     * - Absolute path resolution
     * - Directory exclusion
     * - Windows path escaping
     * 
     * @param pattern Glob pattern for file matching
     * @returns Array of matching file paths
     * @throws Error if file discovery fails
     */
    private async findFiles(pattern: string): Promise<string[]> {
        return await glob(pattern, {
            nodir: true,
            windowsPathsNoEscape: process.platform === 'win32',
            absolute: true,
        });
    }

    /**
     * Command Execution Wrapper
     * 
     * Provides robust command execution with:
     * - Working directory control
     * - Error aggregation
     * - Promise-based interface
     * - Output capture
     * 
     * @param command Command to execute
     * @param cwd Working directory for execution
     * @returns Promise resolving on success, rejecting on error
     * @throws Error if command execution fails
     */
    private async executeCommand(command: string, cwd: string): Promise<void> {
        return new Promise((resolve, reject) => {
            exec(command, { cwd }, (err, stdout, stderr) => {
                if (err) {
                    reject(stdout || stderr || err.message || 'Unknown error.');
                }
                resolve();
            });
        });
    }

    /**
     * Directory Copy Utility
     * 
     * Implements recursive directory copy with:
     * - Recursive structure preservation
     * - File type handling
     * - Atomic operations
     * - Error-tolerant implementation
     * 
     * @param src Source directory path
     * @param dest Target directory path
     * @throws Error if directory copy fails
     */
    private copyDirectorySync(src: string, dest: string) {
        if (!fs.existsSync(dest)) {
            fs.mkdirSync(dest, { recursive: true });
        }
    
        const entries = fs.readdirSync(src, { withFileTypes: true });
    
        for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
    
            try { fs.rmSync(destPath, { force: true, recursive: true }); } catch(e) {}
    
            if (entry.isDirectory()) {
                this.copyDirectorySync(srcPath, destPath);
            } else {
                try { fs.copyFileSync(srcPath, destPath); } catch(e) {}
            }
        }
    }

    /**
     * Atomic File Synchronization Utility
     * 
     * Implements aggressive directory synchronization with:
     * 1. Delta-based file copying (only changed files)
     * 2. Clean target directory pruning (removes orphaned files)
     * 3. Recursive directory handling
     * 4. Atomic write operations
     * 5. Error-resilient implementation
     * 
     * Operation Flow:
     * 1. Scans source directory to determine required files
     * 2. Removes any target files not present in source (clean sync)
     * 3. Creates destination directory structure if missing
     * 4. Performs file-by-file copy with error recovery
     * 
     * Special Features:
     * - Forceful overwrite mode (retries on failure)
     * - Recursive directory handling
     * - Minimal filesystem operations
     * - Cross-platform path handling
     * 
     * @param src Source directory path (must exist)
     * @param dest Target directory path (will be created/cleaned)
     * @throws Error if critical filesystem operations fail
     */
    private brutalSync(src: string, dest: string, restricted: boolean = false) {
        if (fs.existsSync(dest)) {
            const keepers = new Set(fs.readdirSync(src));
            const restrictedFolders = [
                'classes',
                'lib'
            ];
            fs.readdirSync(dest).forEach(f => {
                const fullPath = path.join(dest, f);
                if (!keepers.has(f) && (!restricted ? true : !restrictedFolders.includes(f))) {
                    try { fs.rmSync(fullPath, { force: true, recursive: true }); } catch (e) {}
                }
            });
        }
    
        fs.mkdirSync(dest, { recursive: true });
        fs.readdirSync(src, { withFileTypes: true }).forEach(entry => {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            
            if (entry.isDirectory()) {
                this.brutalSync(srcPath, destPath, restricted);
            } else {
                try {
                    fs.copyFileSync(srcPath, destPath);
                } catch {
                    fs.rmSync(destPath, { force: true });
                    fs.copyFileSync(srcPath, destPath);
                }
            }
        });
    }

    /**
     * Enhanced Smart Deploy Configuration Management
     */

    /**
     * Load or create smart deploy configuration
     */
    private async loadSmartDeployConfig(): Promise<SmartDeployConfig> {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) {
            throw new Error('No workspace folder found');
        }

        const configPath = path.join(workspaceRoot, Builder.CONFIG_FILE);
        
        // Check if config file exists
        if (fs.existsSync(configPath)) {
            try {
                const configContent = fs.readFileSync(configPath, 'utf-8');
                const config = JSON.parse(configContent) as SmartDeployConfig;
                logger.info('Loaded smart deploy configuration from file');
                return config;
            } catch (error) {
                logger.warn('Failed to parse smart deploy config, using defaults');
            }
        }

        // Create default configuration
        this.projectStructure = this.detectProjectStructure();
        const defaultConfig: SmartDeployConfig = {
            projectType: this.projectStructure.type,
            webappName: this.projectStructure.webappName,
            mappings: DEFAULT_MAPPINGS[this.projectStructure.type] || DEFAULT_MAPPINGS.plain,
            settings: {
                debounceTime: vscode.workspace.getConfiguration('turbocat').get<number>('smartDeployDebounce', 300),
                enabled: true,
                logLevel: 'info'
            }
        };

        // Save default configuration
        await this.saveSmartDeployConfig(defaultConfig);
        logger.info('Created default smart deploy configuration');
        return defaultConfig;
    }

    /**
     * Save smart deploy configuration to file
     */
    private async saveSmartDeployConfig(config: SmartDeployConfig): Promise<void> {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return;

        const configPath = path.join(workspaceRoot, Builder.CONFIG_FILE);
        const configDir = path.dirname(configPath);
        
        // Ensure .vscode directory exists
        if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
        }

        // Write configuration file
        const configJson = JSON.stringify(config, null, 2);
        fs.writeFileSync(configPath, configJson, 'utf-8');
    }

    /**
     * Compile mappings for runtime efficiency with cross-platform support
     */
    private compileMappings(config: SmartDeployConfig): CompiledMapping[] {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return [];

        return config.mappings.map(mapping => {
            const absoluteSource = path.join(workspaceRoot, mapping.source);
            const absoluteDestination = mapping.destination;
            
            // Convert glob pattern to regex for file matching with platform-specific logic
            let regexPattern = this.globToRegex(mapping.source);
            
            // Anchor the pattern to match from start to end
            const sourceRegex = new RegExp(`^${regexPattern}$`);

            logger.debug(`[${process.platform}] Compiled mapping: "${mapping.source}" -> regex: ${sourceRegex}`);

            return {
                ...mapping,
                absoluteSource,
                absoluteDestination,
                sourceRegex
            };
        });
    }

    /**
     * Convert glob pattern to regex with proper cross-platform support
     */
    private globToRegex(globPattern: string): string {
        // Platform-specific path separator handling
        const isWindows = process.platform === 'win32';
        const pathSeparator = isWindows ? '\\\\' : '/';
        const pathSeparatorClass = isWindows ? '[\\\\\\/]' : '\\/';
        
        logger.debug(`[${process.platform}] Converting glob: "${globPattern}"`);
        
        let regexPattern = globPattern
            // First, handle glob patterns by replacing with placeholders
            .replace(/\*\*/g, '__DOUBLESTAR__')
            .replace(/\*/g, '__SINGLESTAR__')
            .replace(/\?/g, '__QUESTION__')
            // Escape regex special characters
            .replace(/[.+^${}()|[\]\\]/g, '\\$&')
            // Convert glob placeholders to regex patterns
            .replace(/__DOUBLESTAR__/g, '.*')                    // ** -> match any characters including path separators
            .replace(/__SINGLESTAR__/g, `[^${pathSeparator}]*`)  // * -> match any characters except path separators  
            .replace(/__QUESTION__/g, `[^${pathSeparator}]`);    // ? -> match single character except path separators
        
        // Convert forward slashes to platform-specific path separator pattern
        regexPattern = regexPattern.replace(/\//g, pathSeparatorClass);
        
        logger.debug(`[${process.platform}] Regex result: "${regexPattern}"`);
        
        return regexPattern;
    }

    /**
     * Check if a file matches any compiled mapping with enhanced debugging
     */
    private findMatchingMapping(filePath: string): CompiledMapping | null {
        if (!this.compiledMappings) return null;

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return null;

        // Normalize paths for cross-platform compatibility
        const relativePath = path.relative(workspaceRoot, filePath).replace(/\\/g, '/');
        
        logger.debug(`=== DEBUGGING PATH MATCHING [${process.platform}] ===`);
        logger.debug(`File path: ${filePath}`);
        logger.debug(`Workspace root: ${workspaceRoot}`);
        logger.debug(`Relative path (normalized): ${relativePath}`);
        logger.debug(`Available mappings: ${this.compiledMappings.length}`);
        
        for (const mapping of this.compiledMappings) {
            logger.debug(`\n--- Testing mapping: "${mapping.description}" ---`);
            logger.debug(`Source pattern: "${mapping.source}"`);
            logger.debug(`Compiled regex: ${mapping.sourceRegex}`);
            logger.debug(`Testing against: "${relativePath}"`);
            
            // Test the regex pattern
            const regexMatch = mapping.sourceRegex.test(relativePath);
            logger.debug(`Regex match result: ${regexMatch}`);
            
            if (regexMatch) {
                // Check extensions if specified
                const ext = path.extname(filePath).toLowerCase();
                logger.debug(`File extension: "${ext}"`);
                
                if (mapping.extensions) {
                    logger.debug(`Required extensions: [${mapping.extensions.join(', ')}]`);
                    if (!mapping.extensions.includes(ext)) {
                        logger.debug(`❌ Extension mismatch: ${ext} not in required extensions`);
                        continue;
                    }
                }
                
                if (mapping.excludeExtensions) {
                    logger.debug(`Excluded extensions: [${mapping.excludeExtensions.join(', ')}]`);
                    if (mapping.excludeExtensions.includes(ext)) {
                        logger.debug(`❌ Extension excluded: ${ext} in excluded extensions`);
                        continue;
                    }
                }
                
                logger.debug(`✅ MATCH FOUND: ${mapping.description}`);
                return mapping;
            } else {
                logger.debug(`❌ Pattern did not match`);
            }
        }
        
        logger.debug(`\n❌ No mapping found for: ${relativePath}`);
        logger.debug(`=== END PATH MATCHING DEBUG ===\n`);
        return null;
    }

    /**
     * Generate destination path from mapping and source file with cross-platform support
     */
    private async generateDestinationPath(mapping: CompiledMapping, sourceFile: string): Promise<string> {
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (!workspaceRoot) return '';

        const tomcatHome = await tomcat.findTomcatHome();
        if (!tomcatHome) return '';

        // Get the webapp directory
        const webappDir = path.join(tomcatHome, 'webapps', this.projectStructure?.webappName || '');

        // Get relative path from workspace to handle {relative} placeholder
        const relativePath = path.relative(workspaceRoot, sourceFile);
        
        // Find the matching source pattern base path for correct relativity
        let relativePortion = '';
        
        // Extract relative path based on mapping pattern
        const sourcePattern = mapping.source.replace(/\\/g, '/');
        const sourceBase = sourcePattern.replace(/\*\*\/\*|\*\*|\*/g, '');
        
        // If there's a specific base pattern, use it for extracting the relative part
        if (sourceBase && relativePath.includes(sourceBase)) {
            const baseRegex = new RegExp(sourceBase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
            const sourceMatch = relativePath.match(baseRegex);
            if (sourceMatch && sourceMatch.index !== undefined) {
                relativePortion = relativePath.substring(sourceMatch.index + sourceBase.length);
            }
        } else {
            // Fallback to direct relative path
            relativePortion = path.basename(sourceFile);
        }
        
        // Clean up relative path - remove leading slashes
        relativePortion = relativePortion.replace(/^[/\\]+/, '');
        
        // Replace {relative} placeholder with actual relative path
        let destinationPath = mapping.destination;
        if (destinationPath.includes('{relative}')) {
            destinationPath = destinationPath.replace('{relative}', relativePortion);
        } else {
            // If no placeholder, ensure destination includes the filename
            destinationPath = path.join(destinationPath, relativePortion);
        }
        
        // Create full destination path
        const fullDestinationPath = path.join(webappDir, destinationPath);
        
        // Ensure parent directory exists
        const targetDir = path.dirname(fullDestinationPath);
        if (!fs.existsSync(targetDir)) {
            fs.mkdirSync(targetDir, { recursive: true });
        }
        
        logger.debug(`Mapping ${path.basename(sourceFile)} → ${fullDestinationPath}`);
        return fullDestinationPath;
    }
}